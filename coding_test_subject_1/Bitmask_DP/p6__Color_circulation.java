package Bitmask_DP;

import java.io.*;

// 2482번 - 색상환
public class p6__Color_circulation {

	//비트단위 방문을 적용하기 힘든 이유는 2^1000과 같이 매우매우매우큰 숫자를 담아낼수없다. 비트마스킹은 적어도 할만한 숫자에서만 빠르게 사용가능한 기법이 될것이다. 큰 개수에 비트마스킹은 사용이 안된다. 
	static int N, K;		//	4<=N<=1000	,	1<=K<=N
	static int mod = 1_000_000_003;
	static int[][] dp;
	//=======================================================
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
		K = Integer.parseInt(br.readLine());
		//dp = new int[K+1][(1<<N)-1];	이렇게 하면 쉽기는 한데 비트마스킹이 너무 큰 개수라서 안된다. 
		
		dp = new int[N+1][N+1];	// [가지고있는 색의 개수, 어차피 어느 색이든 상관없으니 현재 색의 번호(까지)로 봐도 된다.][선택한 색의 개수] 	[i][j] = i개의 색이 있을 때 j개의 색을 선택할 수 있는 경우의 수
		
		for(int i=1; i<=N; i++) {
			dp[i][1] = i;	// i개 중에서 1개를 선택하는 방법은 i개이다.
			dp[i][0] = 1;	// 0를 선택하는 경우는 1로 초기화한다. 점화식을 위해서 1로 초기화 한다.
		}
		for(int i=3; i<=N; i++) {	// i가 3미만인 경우는 계산할 필요가 없다. 왜냐면 2일때 j는 1인 경우만 가능한데 이미 1인 것은 값을 초기화 해두었다. 
			for(int j=2; j<=(i+1)/2; j++) {	// n개의 수 중 n/2개 보다 더 많이 고르는 경우는 0가지이다. 그렇기 때문에 다음과 같이 설정한다.
				dp[i][j] = (dp[i-1][j] + dp[i-2][j-1]) % mod;	// i번째 색을 선택하지 않은 경우와 + i번째 색을 선택한 경우
							//그래서 현재 i-1번호까지 j를 골라본 결과는 i번호의 j의 일부가 될수있고, 혹은 i-2번호까지 j-1의 개수를 골라본 경우는 j번호까지 고르면서 그 일부가 되기에 이 둘이 [i][j]를 이룰 수 있다.
			}
		}
		//위까지는 원형이 아니라는 과정하에 계속 진행을 시킨 것이다. 
		//그리고 원형이라는 가정하에는 여태구해준 dp를 통해서 식을 정립할 수 있다.
		//이때도 개수로 보는것보다 번호로 생각하면 편하다. 
	
		// N번째 색을 선택하지 않은 경우 + N번째 색을 선택한 경우
		System.out.println( (dp[N-1][K] + dp[N-3][K-1]) % mod +"");	
		// N번째 색을 선택 안했다면 N번째 색은 제외되므로 1번 색은 사용해도 되기에 [n-1][k]가 일부가 될 수 있다.
		// N번째 색을 선택을 하는 경우라면 '1번째'와 N-2번째를 제외하고 N번째 색을 선택한다면 그 일부가 될 수 있다. 
		// 그 형태는 [N-3]처럼 1번째 , N-1번째, 그리고 선택될 N번째를 제외한 N-3이 되는 것이다. 그리고 이 이전 상태는  아직 N번을 선택할 1개의 선택권이 남은 K-1이다. 이렇게 이전 값을 통해서 이 것들이 일부가 될수있음을 알수있다. 
		
	}//=======================================================
	

}
