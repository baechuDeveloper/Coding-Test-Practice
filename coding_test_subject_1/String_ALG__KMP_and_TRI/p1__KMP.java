package String_ALG__KMP_and_TRI;

import java.util.*;
import java.io.*;
//https://blog.naver.com/kks227/220917078260
/*=========================================================================
 * 문자열 A가 문자열 B 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문자열 매칭 문제

 * 이를 위해서 KMP 알고리즘을 배울 것이다. 어떤 경우라도 O(N+M)에 찾습니다. (N은 A의 길이, M은 B의 길이)
 * 
 * KMP에서는 B의 각 위치마다 별도의 실패함수(failure function)값이 존재합니다.
 * 이 값은 불일치가 발생했을 때 j가 어디로 이동해야 하는지를 나타내는 값입니다. 
 * i는 현재까지 탐색한곳에서 앞과 반복이 되는 위치가 시작되는 곳을 새로운 시작으로 잡고,
 * j는 0부터 다시 시작안하고 실패함수를 통해서 반복되는 위치가 끝난 위치부터 j의 값을 바로 옮겨 불필요한 중복탐색을 줄일 수가 있습니다.
 * 실패함수를 통해서 우리는 중복을 피할수있게 됩니다.  
 --------------------------------------------------------------------------------
 * 실패함수 예시
 * fail(x) = B의 x번째까지 문자열로 만들어 낸  접두사/접미사 중 최대 길이
 * ------------------------
 * x(번까지)   B	   fail(x)
 * ------------------------
 * 0	  a				0
 * 1	  ab			0
 * 2	  abc			0		
 * 3	  abcd			0
 * 4	  abcda			1
 * 5	  abcdab		2
 * 6	  abcdabd		0
 * ------------------------

 * 내가 현재 6번째에서 같은 문자가 안나왔다면, fail(5)로 이렇게 접두사와 접미사에서 일치하는 것 2를 내줍니다. 그럼 다음 i의 위치는 j=2이라는 상황부터 비교해서 시작을 하면 됩니다.
 * 실패함수는 내가 해당 패턴위치에서 실패했다면 그 다음 i에서는 pattern의 어디서(j)부터 시작하는게 좋을지 알려준다. 
 * 실패함수의 리턴값은 현재 들어온 위치값으로 '접두사'의 시작에서 얼마큼의 반복이 있는지 즉 접두사의 어디서 시작되는 것과 같은지를 알려준다.
 * j번째가 실패했다면 j-1로 실패함수를 돌려서 그 이전까지 접두사와 접미사에서 반복된 곳으로 이동하여 새 시작을 한다. 
 * 
 * 여기서는 각 실패함수의 값을 배열로 두어 값을 넣어주는 형태로 했다.
 * 그 배열은 pi로 정해두었고 들어간 배열의 원소값을 실패함수의 매개변수로 여기면 되고, 배열 값이 실패함수의 값으로 보면 됩니다.  
 ==========================================================================*/

// 1786번 - 찾기
public class p1__KMP {
	
	/**pattern의 실패함수 배열 예시-------------------------------------------------------
	 * 위치 |	0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17	
	 * 문자 |	a  b  c  d  a  b  c  e  a  b  c  d  f  a  b  c  d  g
	 * pi값|	0  0  0  0  1  2  3  0  1  2  3  4  0  1  2  3  4  0 
	 -----------------------------------------------------------*/
	/*실패함수의 결과를 배열에 담아두기*/ 
	static int[] getPi(String pattern) {
		int m = pattern.length();
		int j = 0;	//접두사 포지션. 동시에 이 말은 현재의 접미사와 고정된 접두사에게 반복되는게 몇개인지 알려준다. 그리고 다음 i에서는 pattern의 어떤 위치로 '시작으로 하면' i와 비교하는데 쓰일 수 있는지 알려준다.
		//j는 현재 진행되는 상황이다. 다시 말해, 당신은 지금 접두사의 몇번째 해당하는 곳까지 같은 매칭을 연속적으로 이어가고 있음을 알려줍니다.
		char[] p = pattern.toCharArray();
		int[] pi = new int[m];	//0인 값은 그냥 접두사의 맨 처음과 같다. pattern의 접두사 처음부터 다시 비교하세요 라고 알려주는 것이다.
		//i는 접미사의 포지션 //1부터 시작하는건 접두사/접미사는 적어도 2개의 글자부터 진행이 되어서.
		for(int i=1; i<m; i++) {
			while(j>0 && p[i] != p[j])	//접미사가 존재할때, 해당 접미사와 접두사의 현재 진행이 다르다면 이전 단계의 접두사 상태를 가져와서 시작하여 같을때까지 반복한다.  
				j = pi[j-1];
			if(p[i] == p[j])	//중첩이 되는게 있다면 
				pi[i] = ++j;	//실패함수 이용시 접두사에서 시작할 위치를 알려준다. 즉 접두사에서 현재까지 반복된 개수를 적어준다.
		}
		return pi;
	}//=======================================================
	/**--------------------------------------------------------------
	 * str - 전체 문자열
	 * pattern - 찾을 문자열
	 * j - 찾을 문자열(pattern)의 비교 인덱스. pattern에서는 j위치의 문자를 보면되고, str에서는 i를 시작으로 j만큼 증가한 위치의 문자를 지정함.
	 * i - 전체 문자열(str)에 비교할 인덱스이기 때문에 1씩 증가하기만 함. 절대 불규칙적으로 변경 안한다.
	 * i는 str에서 몇 번째 글자를 '시작점'으로 놓고 pattern과 비교하고 있는지 알려주며, 이번 탐색에 쓰일 str에서의 시작번호 (처음은 0부터)
	 * j는 pattern의 몇 번째 글자를 str와 비교하고있는지 알려주는 B만의 번호 (역시 처음은 0부터) 
	 ---------------------------------------------------------------**/
	/*KMP 알고리즘*/
	public static ArrayList<Integer> kmp(String str, String pattern) {
		ArrayList<Integer> ans = new ArrayList<>();
		int[] pi = getPi(pattern);
		int N = str.length();
		int M = pattern.length();
		char[] s = str.toCharArray();
		char[] p = pattern.toCharArray();
		int j = 0;

		for(int i:pi) System.out.print(i+" "); System.out.println();

		/*전체 문자열의 문자는 하나씩 맡아봐야한다.*/
		for(int i=0; i<N; i++) {
			System.out.println("현재 i:"+i+",  j:"+j+"  s[i]:"+s[i]+"  p[j]"+p[j]);
			/*현재 글자가 불일치하면 fail값을 따라가며 j값을 변경함*/
			while(j>0 && s[i] != p[j]) { //같은 크기의 문자가 서로 다르다면 pi배열을 통해서 j를 변경시킨다.
				//중간 단계 뛰어넘기. 이미 검증된 것 넘어간다.
				j = pi[j-1]; //지금 j의 이전 값인 j-1의 실패함수 값은 곧바로 이전까지 완성된 접두사를 확인하고 
							 //그 이전상태까지 이미 체크가 되어서 새로시작하는 곳에서 j=0부터 하지 않고 j=fail(j-1)한 위치부터 시작하면 됩니다. 
							 //시작위치는 항상 하나씩 증가하는 i의 위치부터이며 그 i의 위치기준으로 j=fail(j-1)한 위치에서 '시작하면 된다는 것'을 알려줍니다. 
							 //그 다음 시작하면 되는 위치의 문자와 i의 문자가 같다면 검증된 것을 넘어서 계산을 생략하고 바로 진행이 될 수 있는 것이다. 
				System.out.println("--반복문 변경  j:"+j+"  p[j]:"+p[j]);
				//그때 다음 시작할 위치를 알려주었지만, 그 위치도 아니면 다시 fail함수를 통해 이것도 아니면 더 이전이 이상태로 시작하세요!, 어 이것마저도 안되면 그럼 더 이전 이곳으로..! 하다가 다 안되면 0으로 가게된다 ㅋ
			}

			// P를 S[i : i+M-1]에서 찾음
			if(s[i] == p[j]) {	
				if(j == M-1) { //j는 비교 인덱스로써, 인덱스가 찾을 문자열의 크기에 도달하면 문자열 찾음.
					ans.add(i-(M-1)); //시작위치를 알려준다. //i=0부터 시작한다면 (i - len_B + 1). 문제 조건에 따라 1을 더함 //여러 개의 찾을 문자열이 있을 수 있기 때문
					j = pi[j];	//위에서 pi[j-1]한 값으로 j에게 시작할 위치를 알려준것은 현재의 i에 대해서 시작할 위치와 매칭하기 위해서다. 
								//여기서  pi[j]한 값은 다음 i+1한 값에 대해 시작할 위치와 매칭하기 위해서 이 값으로 실패함수에서 값을 가져온것이다.
								//더 이어서 진행이 될수있는지 파악하는 것이다. 
				}
				else {
					j++;
				}
			}
		}		

		return ans;
	}//=======================================================
	/*main함수*/
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		String A = br.readLine();
		String B = br.readLine();
		
		ArrayList<Integer> ans = kmp(A, B);
		
		bw.write(ans.size()+"\n");	//총 매칭된 개수
		for(int i : ans) 
			bw.write( (i+1) +" ");	//문제에서는 i는 1부터 시작하는 경우로 작동한다. 우리의 풀이는 i는 0부터 시작하는 것으로 작업했다. 그래서 +1
		bw.flush();
	}//=======================================================

}
