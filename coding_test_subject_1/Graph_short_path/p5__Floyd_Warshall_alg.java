package Graph_short_path;
import java.util.*;
import java.io.*;
/**================================================================= 
 * 플로이드 와샬 알고리즘 
 * 이 역시 최단경로 알고리즘이다. 다익스트라와 벨만포드과 다르게 정점 V개가 있고 거리가 다 주어져 있을때, 
 * 단 한 번의 시행으로 모든 정점 쌍 사이의 거리를 다 구해냅니다. 코드는 굉장히 짧은데, 아주 전형적인 3중 for문의 형태를 하고 있고 O(V^3)입니다.
 * 음의 가중치가 있는 간선 그래프에서도 제대로 동작합니다.
  
 * 우선 2차원 배열 dist를 준비해서 그 값들을 INF로 채워줍니다. dist[i][j]=0이라고 하면 자기 자신한테 돌아오게 되는 경우라서 이게 문제에 따라 다릅니다.
 * 아무튼 간선 정보를 갱신할때도 중복된 도시끼리는 더 작은 비용을 선택하도록 합니다. 
 * 위에 까지가 전처리 과정이고 아래가 플로이드 알고리즘 적용입니다. 
  
 * 플로이드는 최단경로를 DP형태의 문제로 정의하고 풀어냅니다. 
 * shortestPath(i, j, k)라는 형태로 주어질 때, 이는 i번 정점에서 j번 정점까지 '1 ~ k-1'번 정점으로 갱신된 정보와 현재 'k'정점을 이용할 때의 최단 거리를 구하라는 의미입니다.
 * 예로 k가 1이면 i와 j번 정점은 k=1인 정점을 거쳐서온 정보를 갱신합니다. 그 다음 k가 2이면 i와 j번 정점은 k=1과 2였던 정점을 거쳐서 온 정보로 갱신합니다.
 * 이대로 계속 진행을하여 k가 N이면 i와 j번 정점은 k=1,2,...,N 였던 정점을 거쳐서 온 정보를 갱신해서 모든 정보를 갱신하여 마무리 됩니다.
 * 여기서 중요한 부분이 1까지 갱신한 내용은 2에 담겨있고, 1~2까지 갱신한 내용은 3에 있으며 ... 계속해서 1~k-1까지 갱신한 내용은 k에 그 내용이 담겨있게 됩니다. 
 * 그렇기 때문에 사실상 k번째 내용을 갱신하기 위해서는 k-1의 정보만 있어도 충분하며  1부터 k-2까지의 각각의 갱신했던 예전 정보는 이미 k-1에 담겨있으니 필요하지 않게 됩니다.
 * 이때, k-1단계 이전의 정보는 더이상 필요하지 않아서 3차원 배열을 쓰지 않고 '슬라이딩 윈도우' 기법을 적용하여 덮어써서 2차원 배열 dist만 가지고도 해결됩니다.
 * 그렇기에 k번의 루프를 통해 마지막 N까지 갱신을 하면 더이상 갱신되지 않는 최단경로 배열 dist가 완성이 됩니다.
  
 * if( dist[i][j] > dist[i][k] + dist[k][j] )
 * 		 dist[i][j] = dist[i][k] + dist[k][j]
 
 * 중요히 해둘 것은 i와 k가'실제 경로상 붙어있는 정점이 아닐'지라도, i정점에서 k로가는 최단거리 경로와
 * 마찬가지로 실제 붙어있지 않아도 k정점에서 j로 가는 최단거리 경로라는 것이다.
 * i와 k, k와 j 그리고 i와 j 가  단 1개의 정점 차이로 거리를 벌려둔게 아닌 수 백개의 정점을 거쳐가야 할지라도 각 정점 사이의 거쳐가는 최단거리가 무엇일지이다.
 * i와 j라는 최단거리를 k라는 중간 다리를 이용해 가장 알맞은 최단거리를 찾아가는 것이다. 그 결과는 정보로서 더욱 업데이트가 되고 
 * 각 '시작정점과 도착정점'에 대한 최단 경로에 대한 거리 값을 얻을 수 있다.
 ================================================================= **/

//11404번 - 플로이드 
public class p5__Floyd_Warshall_alg {
	//클래스변수
	static int N, M;		//도시개수, 버스개수
	static int[][] dist;	//간선(버스) 정보. 인접리스트
	static int INF = 100_000_000;	//1억 	//번외로 Integer.MAX_VALUE도 선언해둔다면 [i][k]와 [k][j]를 더할때 오버플로우가 되서 더 작아지는 값이 나올수 있다. 
	//그러니 최대한의 오버플로우가 피하는 최대 값으로 정해두어라.
	//==========================================
	
	//main함수
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		N = Integer.parseInt(br.readLine());
		M = Integer.parseInt(br.readLine());
		dist = new int[N+1][N+1];
		for(int i=0; i<=N; i++) {
			Arrays.fill(dist[i], INF);
			dist[i][i] = 0;	//무언가를 거치지 않고도 해당 정점과 정점사이는 최단거리 0이다. 자기자신이니깐. 
			
			//그런데 만약 플로이드가 작동하는 방식처럼 무언가 하나의 정점이라도 거치게 하거나, 아니면 다시 자신으로 돌아오는 싸이클 같은 경우라면 
			//똑같이 INF로 둔다면 플로이드의 대상이 똑같이 되어진다. [i][i] i에서 시작해서 i로 돌아오는 싸이클 상 최단거리를 알려줄수있다. 
			//i에서 k의 최단거리 와 k에서 i로 최단거리를 합쳐지는 플로이드 알고리즘에 들어갈수있게되어 i출발해서 i로 도착하는 최단거리를 정확히 알려줄수있다.
			//물론 문제에따라 다른 정점으로 반드시 출발하거나 싸이클을 만들 필요가 없거나 출력상에서 0으로 고정해두었다면 플로이드의 대상으로 만들지않도록 0으로 바꾸어주면 된다.
			// [i][i]도 마찬가지로 플로이드의 자원으로 똑같이 사용되지만 0이면 이미 최단거리라서 갱신도 안되고, 더해지는것도 무의미해진다.
			// INF라면 점점 최단거리로 갱신도 되고, 더해지는데 사용될수도있다.(물론 매우 크다면 안 더해진다. 이건 모두가 마찬가지겠지만)
		}
		//정보 입력 
		for(int z=0; z<M; z++) {	//문제상 M개의 버스 정보를 제공해준다. 
			StringTokenizer st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());	//시작 도시
			int b = Integer.parseInt(st.nextToken());	//도착 도시
			int c = Integer.parseInt(st.nextToken());	//한번 타는데 필요한 비용
			dist[a][b] = Math.min(dist[a][b], c);
		}
		
		//플로이드-와샬 알고리즘
		for(int k=1; k<=N; k++)	//k번 정점
			for(int i=1; i<=N; i++)	//시작
				for(int j=1; j<=N; j++) //도착
					dist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);
		
		//출력
		for(int i=1; i<=N; i++) {
			for(int j=1; j<=N; j++) {
				if(dist[i][j]==INF) sb.append(0+" ");
				else sb.append(dist[i][j]+" ");
			}sb.append("\n");
		}
		bw.write(sb.toString());
		bw.flush();
	}//==========================================

}
