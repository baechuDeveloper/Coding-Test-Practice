package Graph_short_path;
import java.util.*;
import java.io.*;
/****=============================================================================
 * 벨만 포드 알고리즘. 또다른 최단 경로 알고리즘이다.
 * 다익스트라 알고리즘과 마찬가지로 시작점을 정해 주면 다른 모든 정점으로의 최단 경로를 구하는데, 다익스트라 알고리즘보다는 시간이 오래 걸려서 O(EV)의 시간이 걸리지만
 * 이 알고리즘은 간선 cost가 음수일 때도 사용할 수 가 있습니다!!!
 * 아니 도대체 거리가 음수라니 무슨 소리냐, 뭐 그런 거 다 떼어놓고 그냥 최단거리가 정말 작으면 작을수록 좋다고 친다면, 설령 그게 음수가 되더라도 저오학히 구해버린다는 거죠.
 * 그나마 말이 되는 예시를 들자면 거리 대신 이동시간이라 생각하고, 타임머신을 타서 과거로 간다고 생각하는 겁니다. 이떄는 시간을 역행 했으므로 소요시간이 음수가 될 겁입니다.
 --------------------------------------------------
 * 결론으로 다익스트라로는 음의 간선을 제대로 못 반영합니다. 
 * 따라서 벨만 포드 알고리즘은 2중 for문을 통해 철저하게 가능한 모든 경우를 다 체크하기로 합니다.
 * 일단, 최단 경로라는 말은 같은 정점을 두 번 지날 일이 없기 때문에 무한루프가 없다는 가정하에 가능한 최단 경로의 간선 새수는 많아봐야 V-1개 입니다. (큰 for문)
 
 * 우선 혈이라는 표현을 쓸겁니다. 혈이란 dist배열에 들어있는 상태를 말하며 INF이라는 값이 있다면 혈이 막혀있어서 해당 정점으로는 아직 최단경로를 위해 갱신하는데 이용할수 없습니다.
 * 우리는 이 혈을 뚫어가면서 최단경로인것은 더욱 최단경로가 확정되어가고(더 작다면 갱신, 아니면 그대로) 아직 없었던 경로는 새로히 경로로 열리게 될것입니다.
 * 만약 무한 루프가 있다면 최단경로로 갱신해도 갱신해도 끝이 안납니다. 그러니 무한루프가 없다면 혈이 뚫일때마다 또다른 최단경로의 경우를 구해볼수 있는 겁니다. 
 * 그렇게 혈이 뚫이는 건 최대 V-1번을 통해서 할수있는 모든 혈을 뚫어볼 수 있습니다. 이 안에 혈이 못뚫였다면 해당 정점은 어떻게 해서도 도달 할 수 없는 곳입니다. 즉 갈수있는 간선이 없을것입니다.
 * V-1이라는건 최단경로의 간선이 V-1개이므로 최악에 경우 V-1번의 시도를 해야합니다.
 * 
 * 이 경우를 보면 1 -> 5 -> 4 -> 3 -> 2 라는 정점으로 경로를 가진다면 1번의 루프로 5번과 4번이 뚫이고, 2번의 루프로 3번이 뚫이고, 3번의 루프로 2번이 뚫이면서 
 * 경우를 다 찾아갔습니다. 루프마다 최단경로를 갱신하고 새로 생긴 혈을 통해서 새 루프를 열때도 원래 최단경로가 갱신이 될수있고 새로운 경로가 생깁니다.
 * 정상적인 경로라면 V-1번의 루프를 통해서 전체 정점에 해당하는 경우를 알아볼수있습니다. 
 * k=1일때 혈을 통해 정보를 갱신하고, k=2일때 k가 1일때 얻은 정보를 토대로 새로운 혈과 최단경로를 갱신합니다. 즉 k=2는 k가 1일때보다 더 최신정보를 가지고있습니다(누적된 정보). 
 * k=3일때 k=2일때 얻어온 누적된 정보를 통해서 또 새로운 혈과 최단경로를 갱신합니다. 이렇게 계속해서 
 * k=V-1일때 k=V-2일때 얻어온 누적된 정보를 통해서 또 다른 최단경로를 갱신합니다. 그렇게 마지막 V-1까지 도달하면 수학적으로도 모든 정점에서 최단경로를 구하게 됩니다.
 * 물론 여기서는 무한루프도 발생할수있으니 V번도 해보고 이때 만약에 갱신이 되었다면 최대 V-1까지해서 더이상의 갱신이 있는것은 무한루프이기 때문에 갱신이 되었다고 생각할 수 있습니다.
 --------------------------------------------------
 * dist[0]=0에서 시작해서 dist[1]이 0보다 작은 값을 갖을 수 있는 상황이라면 무엇일까 무한루프이다. 그림으로 생각할때 맨처음으로 돌아오는 경로가 있을때, 값이 더 작아지면 어떻게 될까 하는 생각에 답변이다. 
 * 만약 그렇게되면 k=1부터 시작한 시작지점에서 거쳐온 최소 1개의 최단경로 구성을 망가트리게 된다. 그럼 연속적으로 무한루프에 빠지게 될것이다.
 
 * https://m.blog.naver.com/kks227/220796963742
 =================================================================================*/

// 11657번 - 타임머신
public class p4__Bellman_Ford_alg {
	
	//클래스 변수
	static int N, M;
	static long[] dist;
	static ArrayList< ArrayList<Node> > list;
	static int INF = 60_000_000;
	//==================================================
	//정점 자료구조
	static class Node{
		int index, dist;	// 해당 정점의 번호, 이 정점을 연결하는 정점과의 간선 거리 
		Node(int i, int d){
			index = i; dist = d;
		}
	}//=================================================
	//main함수
	public static void main(String[] args) throws IOException {
		//변수 선언
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		dist = new long[N+1];
		Arrays.fill(dist, INF);
		list = new ArrayList< ArrayList<Node> >();
		for(int i=0; i<=N; i++) 
			list.add( new ArrayList<>() );
		
		//내용 입력
		for(int z=0; z<M; z++) {
			st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());	//시작도시
			int b = Integer.parseInt(st.nextToken());	//도착도시
			int c = Integer.parseInt(st.nextToken());	//버스타고 이동하는데 걸린시간
			list.get(a).add( new Node(b, c) );
		}
			
		//벨만 포드 알고리즘 적용 (무한루프가 나오면 -1로 처리)
		boolean minusCycle = false;
		dist[1] = 0; //맨 처음에는 1번만 혈이 뚫여있다. 시작지점만 뚫고 시작한다.
		for(int k=1; k<=N; k++) {		// 큰 루프 V번(한번의 루프를 통해 적어도 1개의 최단경로는 완성하다고 생각하고 최악의 경우 N-1, 어떤 정점은 혈이 막혀있어서 진행이 안되지만 N-1번을 돌면서 갱신을 하게되면 가능한 모든 경우의 혈이 뚫여있다. 이렇게 해도 못뚫인 혈은 지나가는 간선이 존재하지 않는 경우이다.). 
		// 전체 정점으로 만들어내는 최대 간선의 개수는 N-1개이기 때문에 최대 횟수만큼 시도해보는 것. 다만, (N-1) + 1번의 루프. 마지막은 음의 싸이클 존재 여부 확인용
			
			for(int i=1; i<=N; i++) {	// 시작 정점. 밖에 'k에 있는 for문 N-1'번의 루프에 걸쳐 각 정점이 N개 정점을 거쳐오는 최단경로 갱신
				for(Node nextNode: list.get(i)) {	//간선. (위에 i의 for문까지 합쳐서 E번 )해당 정점의 인접리스트를 가져와서 각각의 정점으로 확인한다.
					int next = nextNode.index;
					int d = nextNode.dist;
					if(dist[i]!=INF && dist[next] > dist[i] + d) {	//시작정점이 INF라면 혈이 막혀있다, 원래 가지고있던 인접 정점의 거리보다 더 작은 값을 가질 수 있다면 갱신한다.
						dist[next] = dist[i] + d;
						if(k==N) minusCycle = true;	//k==N일때 이곳까지 들어왔다면 또 갱신이 된다고? 이런 소리가 되기에 무한루프의 형태로 돌고있구나 알 수 있다.
					}
				}
		}}
		
		//답 출력 
		if(minusCycle) bw.write("-1");
		else 
			for(int i=2; i<=N; i++) 	// 2번도시부터 나열해준다.  
				bw.write( (dist[i]==INF ? "-1" : dist[i]+"") +"\n");
		bw.flush();
	}//==================================================

}
