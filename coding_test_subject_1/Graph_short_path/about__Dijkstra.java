package Graph_short_path;
import java.util.*;

public class about__Dijkstra {

	/**===============================================================================
	 * 그래프.. 정말 어렵고, 답없고, 온갖 문제가 많기로 유명합니다.
	 * 그중에서도 처음을 장식할 최단 경로 알고리즘은 그 종류부터 3개나 됩니다. 첫번쨰로는 다익스트라 알고리즘에 대해서 알아보겠습니다. 
	 -------------------------------------------------------------------------------
	 * 다익스트라 알고리즘
	 * 이 알고리즘이 하는 일은 그래프의 '어떤 정점 하나를 시작점'으로 선택하고, '나머지 정점들로의 최단거리'를 모두 구합니다. 시작점 자신이야 뭐 그냥 0입니다.
	 * 정점 개수가 V, 간선 개수인 E일 때 기본적인 최적화를 거치면 O(ElogV)의 시간복잡도를 갖습니다. 
	 * 그래프는 무향이거나 유향인데 대체로 유합인 경우가 많고, 간선마다 이동거리가 존재합니다. 또한 '모든 거리값이 음수'가 아닐 때만  사용할 수 있습니다.
	 * 이 이동거리가 거리 대신 비용(cost)이라는 용어로 대체되고서 최소비용을 구하라고 할 수도 있는데 같은 표현입니다.
	 ----------------------------------------- 
	 *   작동방법
	 * 	1. 반복문의 방문 규칙은 현재 위치의 점에서 아직 방문하지 않은 정점들 중 '거리가 가장 짧은 정점'을 하나 선택해 방문한다. 
	 *  2. 방문을 했다면 해당 정점에서 인접할 수 있는 정점들의 거리들을 비교하여, 현재 테이블보다 값이 작은 경우의 해당 정점에 대해서는 테이블 갱신하고 
	 *     우선순위 큐에 넣어서 방문 후보로 넣어준다. 이를 인접한 정점에 대해 모두 비교를 하여 가능하다면 넣어주도록 한다. 
	 *     해당 정점에서 인접한 것을 모두 확인했다면 1로 넘어간다.
	 *    
	 *  우선순위 큐를 사용한다. 해당 정점을 '방문'했다면 방문했다는 표시를 해준다. 또한 방문했다는 의미는 그 정점을 향한 최소거리가 확정이 된것이다. 
	 *  수학적으로 생각하면 반드시 그렇다. 그래서 방문했다는 것을 확인하면 이미 확정이 되었구나 하고 다음 우선순위 큐로 방문하면 된다.
	 *  
	 *  맨 처음에는 시작점으로의 거리만 0이고 나머지는 다 거리가 무한입니다. 테이블 dist에 그 정보를 넣어둡니다. 
	 *  
	 ------------------------------------------
	 *  중요한 것중 하나가 '인접리스트' 이다. 
	 *  흔히 그래프에서 많이 보게될 표현인데... 
	 *  그래프의 정보를 int[][] arr로 담아서 넣어두는 것도 흔하다. 이것을 '인접행렬'이라고 한다. 
	 *  ArrayList 같은 리스트를 사용해서 그래프를 표현해준다면 '인접리스트'라고 한다.
	 *  이때 인접리스트는  ArrayList< ArrayList<Integer> > listGraph = new ArrayList< ArrayList<Integer> > ();
	 *  으로 두어서 그래프를 표현해 줄 수있다. 인접행렬이면 O(V^2)의 시간이 필요하지만, 인접리스트라면 O(ElogV)의 시간이 필요하게 된다. 
	 *  
	 *  인접행렬의 장점은 정점간의 간선이 있는지 확인할때 정점 v1,v2 에 대해 '한 번의 접근으로 확인'이 가능하지만, 인접 노드를 찾기 위해선 모든 노드를 순회해야한다. 
	 *  인접리스트는 해당 정점끼리의 간선을 리스트의 처음부터 하나씩 확인을 해야지만, 인접 노드를 쉽게 찾을 수 있다.
	 *  
	 *   그래서 인접 행렬과 인접 리스트가 사용되는 경우는 다음과 같습니다.
	 *   인접 행렬 : 그래프에 간선이 '많이' 존재하는 '밀집 그래프'
	 *   인접 리스트 : 그래프에 간선이 '적게' 존재하는 '희소 그래프'
	 --------------------------------------------
	 * 아래 내용을 다 따라하진 않아도 되니 내용이해를 위해 적었다. ArrayList<ArrayList<Integer>>를 이용하도록 한다. 
	 
	 * 주의할 예외사항은 만약 연결그래프가 아니거나(연결이 덜됨), 유향 그래프라면 모든 정점에 대해서 돌아 보지 못할수 있다. 
	 * 그래서 꼭 V-1번 돌지 못할 수 있어서 못 돌아본 정점은 값이 INF인 값으로 남아있을 것이다. 즉 시작점에서 그 정점으로는 갈 수가 없다는 뜻이겠지요.
	 ====================================================================================*/
	//인접리스트 자료구조===================================================
	class ListGraph {
		//그래프 
		private ArrayList< ArrayList<Integer> > listGraph;	//물론 알고있지만 다시 적어보자면 ArrayList< ArrayList< > > 이 표현은 [][]와 같은 표현이며 가장 바깥에 있는게 행, 안쪽이 열이다.
															//그 떄 정보의 표현이 정수면 <Integer>이다. 알고있지만 더 확인해본다. 
		//생성자
		public ListGraph(int initSize) {
			this.listGraph = new ArrayList<> (); //new ArrayList< ArrayList<Integer> > ();

			for(int i=0; i<initSize+1; i++) {	//1부터 그래프의 번호 시작이니 initSize까지 포함
				listGraph.add( new ArrayList<Integer>() );	// 각 정점 마다의 리스트를 구성해줌
			}

			/* -----------예로 본다면 
			 * [0]  			여기는 사용하지 않는다.
			 * [1] -> 2 -> 4
			 * [2] -> 1 -> 5 -> 3
			 * [3] -> 8 -> 7
			 * 이렇게 담겨져서 사용하여 인접행렬에 비해 없는 값을 위한 공간을 낭비하지 않게 된다.*/
			// 공간을 낭비하지 않고 주어진 정보만 들어있으니, 해당 정점에서 탐색에 필요한 것만 골라올 수 있다. 
			// 반면에 인접행렬은 해당 정점에서의 필요한 값만 얻어오고 싶어도 불필요한 부분까지 리니어하게 탐색을 해야하므로 불필요한 연산과 공간이 들어간다.
		}
		//그래프 return 
		public ArrayList< ArrayList<Integer>> getGraph() { //그래프 전체를 가져온다. 
			return listGraph;	 
		}
		//그래프의 특정노드 return
		public ArrayList<Integer> getNode(int i) { //'해당 정점'에 리스트(정보)를 가져온다. 
			return listGraph.get(i);
		}
		//그래프 추가 (양방향)
		public void put(int x, int y) {
			listGraph.get(x).add(y);
			listGraph.get(y).add(x);
		}
		//그래프 추가 (단방향)
		public void putSingle(int x, int y) {
			listGraph.get(x).add(y);
		}
	}//=================================================================
}
