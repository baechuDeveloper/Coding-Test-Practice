package Greedy;

public class about__Greedy {

	/**
	 * 탐욕 알고리즘, 그리디 알고리즘은 해결하는 과정에서 그 순간순간마다 최적(매번 가장 좋아보이는 답)이라고 생각되는 결정을 하는 방식으로 진행해서 
	 * 최종 해답에 도달하는 문제 해결방식이다. 동적계획법과 마찬가지로 최적화 문제(가장 최소,최대의 답, 원하는 답에 접근)를 푸는데 사용한다. 
	 * 동적계획법보다 효율적이긴 하지만 동적계획법처럼 반드시 최적의 해를 구해준다는 보장이 없다.
	 * 일단 출발한다. 그리고 최적마다 접근한다... 다만 매번 최선의 결정을 하게 되지만
	 * 그것이 언제나 '최적'이라고 보장이 안될수가 있다. 분기마다 좋은 것이라고 반드시 최적이라는 보장이 없다는 말이 된다.
	 * 다만 장점으로는 빠른 계산 속도에 있어서. 그리디가 통하는 몇몇의 문제에 대해서는 빠르게 산출할 수 가 있다.
	 * 
	 * 대표적으로는 활동 선택 문제(Activity Selection Problem)으로 그리디를 적용할 수 있다.
	 * 
	 * Greedy는 '탐욕스러운 선택 조건'과 '최적 부분 구조 조건' 이 2가지의 조건이 성립이 되어야 제대로 잘 작동한다.
	 * '탐욕스러운 선택 조건' - 앞의 선택이 이후의 선택에 영향을 주지 않는 조건. greedy choice property
	 * '최적 구분 구조 조건' - 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 최적의 방법이다 라는 조건.
	 
	 
	 * 다이나믹 프로그래밍과 비교를 한다면 DP는 전체 문제를 여러 개의 하위 문제로 나누어 풀고, 
	 * 하위 문제들의 해결 방법들을 결합하여 최종 문제를 해결하는 문제 해결 방식이다.
	 * 다시 이를 보자면 최종문제를 해결하는 많은 (작은)방법들을 모두 탐색하게 된다. 
	 * (상위를 위해 필요한)하위 문제들 각각의 해결 방법들을 모두 탐색하기 때문이다.
	 * 모두 탐색할지라도 반복되는 하위 문제를 찾아 간단히 해결하도록 만드는 형태를 취하게 하여 계산 횟수를 줄일 수 있다.
	 * 이게 DP로서의 문제 해결 방법이다. 
	 * 
	 *  즉 둘다 의도에 따르면 그 의도가 분명하다. 그리디는 항상 현재에 최적에 맞는 상황으로 값을 이끌어 가는 해결방식을 지침하며
	 *  다이나믹은 하위문제로 나누어 풀어 이를 결합하여 최종에 다가가는 해결방식이다. 동적계획법은 최적의 해법이라고 말할 수 있다. 
	 *  왜냐하면 일일이 검토하여 최적해를 찾아내는 주먹구구식 방법이라고 볼수있어도 전체 상황을 모두 고려한 최적방법이다.
	 *  
	 *  만약 최적의 조건으로'만' 따르고 있다면 분명히 그리디적인 측면을 가지고 있다고 볼 수 있다.
	 *  또 만약 문제상에서 하위문제로 나누어 보며 결합하는 상황과 테이블을 구비했는데 점화식이나 필요한 조건등이 최적 최소라면 이건 DP적 측면이 있음을 알수있다.
	 *  단지 조건만이 최적일 뿐이고 여기서 이 조건만 보고 다이나믹처럼 문제를 나누어 결합하지 않고 하위 문제에 방법을 검토하지 않는다면 
	 *  그것은 단지 현재에 맞는 최적만을 보고 순간순간에 최적에만 의존하며 전체적인 상황을 알수가 없는 조금 일반적인 그리디적인 방법으로 볼수있다.
	    --------------------------------------------------------------------------------------
	 *  이 아래부터 내용이 약간의 오해가 있을수있는데, 그리디이든 DP든 항상 무조건 그리디이다, DP이다 이렇게 정해두는게 아니다.
	 *  DP에도 조건상에 그리디가 있을수있고, 바이너리할때도 DP를 이용하기도하며 모든 상호작용이 될수있다.
	 *  이 뿐만이 아니라 다른 모든 알고리즘에도 여러 방법들로 접근하면 다 이렇게 오호 이런 개념을 갖고 여기에 붙여서 진행해보는구나 이다. 
	 *  어떠한 조건상에서 그리디 알고리즘 개념을 이용해서 진행을 하는구나 라고도 볼수있고, 여기서는 DP적인 측면으로 문제를 나누어 저장해가는구나.
	 *  그러면 그건 이러한 부분에선 그리디알고리즘의 분류로도 포함이 될수있고, 여기 부분에선 DP의 분류에도 포함이 될수 있겠다. 
	 *  이렇게 생각해주면 가장 맞는 생각이 될것이다. 아래에 내용처럼 반드시 그렇다는 조건이 아닌 개념적인 측면에 이 파트를 그리디적으로 생각해서 접근했군. 
	 *  이렇게 부분적인 개념을 내가 알고있는 지식으로 겹치고 여러 부분을 융합해서 사용이 되어지고 있다.
	 *  (다른 모든 알고리즘은 여러 분류에도 포함되기도 할수있다. 물론 안그럴수있다해도 여러곳에 들어갈수있음을 기억해두자.)
	 	--------------------------------------------------------------------------------------
	 *  (x)다이나믹에서 그 조건상 최소 최적 같은 걸 따른다고 그리디랑 섞인건가? 싶다면 전혀 다르다라고 말할수있고, 
	 *  그저 다이나믹에서 점화식 조건이 그런거지 전혀 연관이 있지 않다. 다이나믹 구조없이 현재 최적의 조건을 따르는 기준으로 진행하면 '그리디'.
	 *  다이나믹 구조를 따른다면 그저~ '다이나믹 프로그래밍'. 필요한 조건이 최적이든 뭐든 그건 부가적인 요소이며. 
	
	 *  (x)다이나믹에 그리디를 적용했다라고 이상한 말을 하지말자. 
	 *  "최적이라는 표현은 그리디만의 것이 아니다!"   '현재'의 '최적''그 자체만' 따르는 해결방식이 그리디다.
	 *  최적이라는 표현은 모두가 사용가능하다. 그저 조건의 표현이다.
	 * 	 * **/
}
