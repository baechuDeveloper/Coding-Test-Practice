package Tree_DP;

import java.io.*;
import java.util.*;

/**-----------------------------------------------------------------------------
 * 그래프란 정점과 정점으로 잇는 간선들로 이루어진 집합이다.
 * 만약 간선 없이 있는 정점이 있다면 해당 정점은 다른 어떤 정점과는 '하나의 그래프'는 아니다.
 * 그 해당 정점이 하나의 그래프가 된다.
 * 따라서 그래프란 자신과 연결되어있는 정점의 집합이라고 보면 된다. 그래서 따로 떨어진 정점과는 같은 그래프가 아니다.
 *
 * 문제에서도 그래프에서 라는 말을 한다. (여러 그래프라고 언급했으면 모르지만, 그래프 G에서 라는 말을 한다.)
 * 따라서 그래프라는 언급으로 인해 따로 '홀로 떨어진 정점'은 있을 수 없다.
 *
 * 또한 여기선 그래프에서 싸이클이 없는 경우인 트리라고도 언급해준다. 하나의 그래프에 대해서 이니 당연히 하나의 트리이다.
 -----------------------------------------------------------------------------**/
/**----------------------------------------------------------------------------
 * https://baami.tistory.com/3
 * NP하드 문제이다.
 * 트리의 루트를 어떤것으로 잡아도 해당 트리는 유지가 된다. 따라서 우리는 트리의 루트를 1이라고 생각해두고
 * 트리를 타고 내려가면서 뻗어가는 작업으로 진행하면 된다.  
 --------------------------------------------------------------------------------*/
// 2213번 - 트리의 독립집합
public class p2__Tree_Independence_Set {
	/*클래스변수*/
    static int N;   //정점 개수수
    static int[] weight;
    static int[][] dp;
    static ArrayList< ArrayList<Integer> > childList;
    static ArrayList<Integer> ans;
    //===============================================================================
    /*main함수*/
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        N = Integer.parseInt(br.readLine());
        weight = new int[N+1];
        dp = new int[N+1][2];
        for(int i=0; i<=N; i++)
            Arrays.fill(dp[i], -1);
       
        /*가중치 입력*/
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i=1; i<=N; i++)
            weight[i] = Integer.parseInt(st.nextToken());

        childList = new ArrayList<>();
        for(int i=0; i<=N; i++)
            childList.add(new ArrayList<>());
        ans = new ArrayList<>();

        /*간선 입력*/
        String str = "";
        while( (str=br.readLine())!=null && str.length()!=0) {
            st = new StringTokenizer(str);
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            childList.get(a).add(b);
            childList.get(b).add(a);
        }
        
        /**------------------------------------------------------------------------
         * dp를 완성시킨다. 노드 1을 포함 할 때와 안 할때를 하면 모든 경우의 DP를 찾아볼 수 있게된다. 
         * 한번이라도 갱신된 해당 dp배열 값은 다시 해당 dp를 방문을 하는 것이 나와도
         * 더이상 뻗어나가는 작업 없이 그저 값만 제공해주면 되므로 DP로서 작업이 완성된다.
         * 
         * case_X는 노드 1을 포함하고 시작하는 경우로, 뻗어나간 작업을 모두 리턴해와서 
         * 마지막으로 남은 갱신못한 dp[1][0]을 마지막으로 갱신을 완료한다. 
         * 
         * 아직 dp[1][1]은 갱신을 못했다. 즉 더 뻗어나가서 갱신을 하는 작업이 필요하다.
         * case_O는 노드 1을 포함하지 않고 시작하는 경우로, 마찬가지로  마지막으로 갱신 못한 dp[1][1]을 갱신을 완료한다.
         -------------------------------------------------------------------------**/
        int case_X = solution(-1, 1, 0); //노드 1을 포함하고 시작 		
        int case_O = solution(-1, 1, 1); //노드 1을 포함하지 않고 시작 

        /* ---------------------------------------------
         * 구해본 두가지 값을 토대로 어떤 경우가 더 좋을지 판단한다. 
         ----------------------------------------------*/
        if(case_X > case_O)
            tracking(-1,1,0);	//만약 처음 1번노드부터 포함하지 않은게 더 좋은 값이면 이때의 트래킹을 한다.  
        else
            tracking(-1,1,1);	//반대로 처음 1번노드를 포함하는게 더 좋으면 이것으로 트래킹을 한다.
        
        /*포함시킨 노드를 오름차순으로 정렬해서 보여준다.*/
        ans.sort(null);

        bw.write(Math.max(case_X, case_O)+"\n");
        for(int i:ans)
            bw.write(i+" ");
        bw.flush();
    }//===============================================================================
    
    /*DP배열을 완성시키는데 사용되는 함수*/
    static int solution(int prev, int now, int state) {
    	 /**--------------------------------------------------------------------------
         * DFS하게 진행을 한다. 따라서 트리의 끝에 도달하면 그 값이 되돌아오면서 dp배열의 값을 갱신한다. 
         * 한번 갱신된 dp배열은 이제 다시 이곳을 방문하면 그저 값만 제공해주면 된다. 
         * 방문한 곳에서만 그 방문의 (포함 혹은 안 포함인 것에)갱신이 이루어진다. 
         * 현재 방문한 now곳이 state가 0이면 이곳을 포함안하고 방문을 할 때 경우, 1이면 포함하고 방문을 했다는 경우
         ---------------------------------------------------------------------------**/
        /*이미 방문을 해서 값을 지정 했다면 구해 놓은 값을 보내준다.*/
        if(dp[now][state] != -1) 
        	return dp[now][state];

        /*state가 1이면 이곳을 방문 한다는 뜻*/
        if(state==1)
            dp[now][state] = weight[now];
        else
            dp[now][state] = 0;

        ArrayList<Integer> childNode = childList.get(now);
        for(int next : childNode) {
            if(next==prev) continue;	
            /**--------------------------------------------------------------
             * 위 조만 해도 경로의 중복이 예방되는것이, 우리가 현재 다루고 있는게 트리라서 싸이클은 존재하지 않는다. 
             * 따라서 루트부터 시작한 작업이 다시 뒤로 돌아가는 진행만(물론 당연히 막아야 된다) 막으면 아래로 내려가는 작업만 진행하고 
             * 아래로 내려가는 작업에 뽑혀지는 노드 번호도 단 한번씩만 나타나는게 트리의 상황이다. 
             * 그와 동시에 우리가 한번 dp의 배열값을 갱신해서 이후에 이곳을 방문을 할 때는 뻗어 나가지 않고 
             * 값만 제공해주면 되는것으로 이미 방문한 곳은 더이상 뻗어나가지 않게도 해준다.
             
             * case_X을 통해서 갱신된 dp배열을 case_O에서만 재사용에 이용되는건 아니다. 
             * 왜냐면 트리구조이기 때문에 case_X에서 한번 방문한 노드는 더이상 방문을 하지 않아도 된다고 생각하지만, 여기서 중요한점은 포함해서 방문한다와 포함안하고 방문한다이다.
             * 만약 그저 방문만 하는 것만 한다면 한번 방문한 노드는 더이상 방문을 하지 않게 되는게 맞다. 다만 여기서는 만약 내가 이곳을 포함안한다는 상황에 방문을 했다면 
             * 그 다음 것을 포함시켜서 방문하여 가져온 정보일수도 있고, 포함안해서 방문한 정보로 진행할 수 있다. 이게 중요하다. 내가 이곳을 포함을 안하고 방문을 할것이다(state==0)면 
             * case_X에서도 다시 2번의 경우 max(solution(now, next, 0), solution(now, next, 1))를 더 진행을 하는데 
             * 이 상황은 같은 진행 경로에 대해서도 2번의 경우를 진행해보는 것이라서 이미 구해본 정보를 다시 사용되는 상황이 나오게 된다.  
             * 똑같이 case_O에서도 이와 같은 이유로 연산의 중복을 방지하는데 이미 갱신이 된 dp배열을 재사용해서 이용할 수 있게 된다.
             * 
             * 요약하면 다시 원래의 간단함으로 돌아오자. 
             * 뒤로가는 진행만 막는다면 트리의 아래로 쭉 뻗어나가는 진행을 한다. 왜냐면 트리이니깐
             * 이미 구해본 값은 해당 값 제공해주면 된다. 그러면 뭐든간에 재사용이 된다. 다만 트리라서 보통 case_X는 한번만 방문을 하기에 재사용 안할것 같지만서도,
             * 현재가 포함 안하는 방문을 한 곳으로 본다면 다음 진행은 '같은 진행'인데도 옆을 포함한다, 안한다라는 2가지 경우의 방문으로 인해 case_X도 case_O도 그런거 없이 모두가 재사용을 쓴다. 특히 case_O은 더 개꿀빤다.
             
             * 결론 : 뭘해도 이미 (포함하든,안하든 이미 갱신한)방문한 곳은 더 뻗어나가지 못하게 한다는 생각이 항상 모든것의 기초가 된다. 여기에 그저 이해를 위한 의미를 조금 붙인거라 여담일 뿐이었다.
             --------------------------------------------------------------**/

            if(state==1)
                dp[now][state] += solution(now, next, 0);   //내가 현재 이곳을 포함시켜서 방문을 한것이니, 붙어있는 다음 것은 포함을 시키지 않는다.
            else
                dp[now][state] += Math.max(solution(now, next, 0), solution(now, next, 1)); //내가 현재 이곳을 포함안시키고 방문했기에, 다음 것을 포함시키지 않거나 포함을 시킨다.
        }

        return dp[now][state];
    }//===============================================================================
    
    /*이곳을 통해서 독립 집합에 포함이 되는 번호들을 적어준다.*/
    static void tracking(int prev, int now, int state) {
        ArrayList<Integer> childNode = childList.get(now);

        if(state==1) {	//현재를 포함하도록 방문 했다면
            ans.add(now);	//해당 노드는 포함이 된 것으로 남겨준다.
            for(int next:childNode) {
                if(next == prev)
                    continue;
                tracking(now, next, 0);	//모두 포함이 안된 방문으로 다음을 진행한다.
            }
        }
        else{			//현재를 포함하지 않도록 방문을 했다면 
            for(int next:childNode) {
                if(next == prev)
                    continue;
                if(dp[next][1] >= dp[next][0])	//다음 방문을 할 때, 해당 노드를 포함하는게 더 좋을지 아닌지 보고 그것으로 트래킹한다.
                    tracking(now, next, 1);
                else
                    tracking(now, next, 0);
            }
        }
    }//===============================================================================
}
