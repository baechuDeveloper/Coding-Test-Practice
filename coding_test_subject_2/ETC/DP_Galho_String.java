package ETC;
import java.util.*;
import java.io.*;

// int는 32비트, long은 64비트 

// 1023번 - 괄호 문자열 
public class DP_Galho_String {
	
	static int N;
	static long K;
	static StringBuilder sb;
	static long[][][] dp;	//[wrong_flag][pos][cnt]
	//=============================================
	//dp의 방식중 Top-Down은 이렇게 하나씩 왼쪽에서 오른쪽 방향으로 진행하며, 그걸 트리형태로 저장을 한다면 효과적인 방식의 메모이제이션으로 이용할 수 있었다.  
	/**-------------------------------------------------------------------
	 * dp에 정확한 의미는... [wrong]을 우선 신경 안쓴채로 [pos][cnt]적으로 의미를 전달해보자면... 1번부터 pos번 까지 진행을 한 상황에서 '('의 개수와 ')'의 개수의 차이만큼 진행했을 때 만들 수 있는 괄호 개수 
	 * 이때 wrong이 0(false)이면 정상적인 괄호로 만들 '가능성이 아직 남은' 상태이며, wrong이 1(true)이면 절대로 정상적인 괄호로 만들 가능성이 없는 상태임을 말한다. 한번이라도 cnt가 음수가 된다면 wrong은 계속 1로 되며 계속 비정상 괄호만 만들게 된다.
	 
	 * 여기서 궁금하게도 그렇다면 당연히 맨처음 wrong이 1인 [1][1][-1]은 N의 절반에 해당하는 값을 가져가는 것이 맞는데 왜 바로 값을 입력 안하고 맨 끝까지 더 진행하냐면 dp를 채우는 것에 의의를 둔것이 된다. 그 과정을 막힘없이 하기위해서는 막을 필요가 없다. 
	
	 * 마지막에 pos에 끝자락에 도달하고 cnt의 정보와 wrong의 상태정보로 현재 정상적인 괄호라면 0을 주고, 비정상적인 괄호라면 1을 준다.
	 * dp가 참 신기한게 마지막에 도달된 녀석에게는 자신이 비괄호인지 아닌지를 알려주도록 1개인지 0개인지 알려주는데 윗 녀석들에게는 이걸 합쳐줄 개수를 알려주게 되고, 
	 * 이미 구해본 값(똑같은 상황의 값)은 값을 공유한다. 이게 신기하게도 '(()?'와 '()(?'가 같은 상황임을 알려주게 된다.
	 * 만약 자신과 같은 상황인 녀석이 또 나온다면 예를들어 N은 4일때'(()?'와 '()(?' 은 서로 wrong은 0이고, pos는 3, cnt는 1이다. 
	 * '(()?'은 '(()('와 '(())'으로 갈라지고... '()(?'은 '()(('와 '()()'으로 갈라진다. 
	 * 둘의 진짜 괄호의 위치는 달라도 pos와 cnt의 정보 그리고 wrong의 상태를 가지고 있다면 둘의 상황을 예상가능하다. 가장 큰 이유는 이분으로 2가지 선택으로 나뉘는 것이 바로 앞으로 몇개의 상황으로 될지 합리적으로 흘러가기 때문이다.
	 * 그 정보는 wrong의 정보가 있기 떄문에 비로소 합리적으로 예상이 되는것이다. 이 3개의 정보가 무슨 짓을 해도 앞으로 서로 같은 개수를 가지게 되는 구나를 알려준다. 그게 이 dp의 가장 큰 의의다.
	 
	 * 다만 '(()?'와 ')((?'의 상태는 wrong이 다르다. 결과 값도 '(()?'은 1이지만, ')((?'은 2이다. 서로 다른 상황이다. 
	 * 
	 * 결과적으로 dp[0][0][0]에 길이 N에 대한 모든 비정상적인 괄호들의 개수가 들어가게되는데.. 이는 트리 구조로 아래로 퍼져나가는 그림에서 그 아래로 파생할수있는 개수가 몇개인지 알려주는게 바로 dp의 의미다.
	 * 즉 dp[0][0][0]은 dp[0][1][1]과 dp[1][1][-1]의 형태로 나뉘어 진다. 이때[1][1][-1]로 계속 아래로 퍼저나가는 것들은 모두 wrong이 true가 되므로 비정상적인 괄호이다.
	 * 대신 그 개수가 몇개인지는 알아야 되므로 계속 진행을 한다. 
	 * -------------------------------------------------------------------*/
	
	// 이걸 통해 전부 dp[0][0][0]으로 비정상적 괄호의 개수가 모이게 될것이다. 
	// pos는 현재탐색하는 위치, cnt는 열린괄호-닫힌괄호 수, wrong은 1~(i-1)번째 문자열이 이미 잘못된 괄호문자열 인지 판단 0이면 false(아직정상), 1은 true(이미 비정상) 
	// 맨 왼쪽 1번위치부터 맨 마지막 N위치까지 진행을 하며 몇개의 비율로 가질지 그리고 앞으로도 가능성 상태를 갖고 진행하는 Top-Down방식이다. 메모이제이션으로 한번 얻은 같은 상황은 되돌려 준다. 
	static Long findGalho(int wrong, int pos, int cnt) {
		if(pos == N) 
			return dp[wrong][pos][cnt+N] = (wrong==1||cnt!=0) ? 1L : 0L;	//마지막에 도달한 녀석에게는 정상이면 0개를 주고, 비정상이면 1개를 준다. 
		long cache = dp[wrong][pos][cnt+N];
		if(cache != -1) return cache;	//이미 정해진 값이 있다면 바로 그 값을 이용하면 된다. 
		dp[wrong][pos][cnt+N] = 0;
		dp[wrong][pos][cnt+N] += findGalho( 				wrong, pos+1, cnt+1);	//다음위치를 '('를 추가해서 간다. 
		dp[wrong][pos][cnt+N] += findGalho((wrong==1||cnt<=0)?1:0, pos+1, cnt-1);	//다음위치를 ')'를 추가해서 간다. 이때 추가하면 cnt가 마이너스가 되면 어떻게 될지 알린다. 
		return dp[wrong][pos][cnt+N];		
	}//=============================================
	
	/**
	 * 이 원리는 2가지로 인해서 작동한다. 
	 * 1번째는 이분탐색과 똑같은 방식으로 진행이 가능하다. dp[0][0][0]가 루트가 되어 아래로 이분으로 나뉘어져 트리가 구성된다. 
	 * 2번째는 이분탐색과 마찬가지로 현재 노드 기준 왼쪽 자식들은 오른쪽 자식보다 항상 더 낮은 값을 갖게 된다. 괄호에서 이게 무슨 의미냐면 '('은 0, ')'은 1이라고 생각하고 이진법으로 보면 된다.
	 * [0][0][0]에서 [0][1][1]과 [1][1][-1]으로 나뉘어지는데 [0][1][1]은 '(...'으로 시작하므로 '0...'인 이진법이고, [1][1][-1]은 ')...'으로 시작해서 '1...'인 이진법이다. 
	 * 왼쪽 오른쪽으로 나뉘는 기준도 이분탐색하는 방식으로 알맞게 되었다. 
	 * 따라서 현재 나뉘어지는 두 자식 dp의 상태중  
	 * */
	static void trackingParen(int pos, int cnt, int wrong, long k) {
		if(pos == N) return;	//너한테는 더이상의 자식이 없다. 부모가 미리 자식의 정보대로 print에 넣어주므로 return만 해도 다 끝난다.
		
		/**만약 왼쪽 자식으로 가야한다면, 즉 (을 붙여야 하는건가 물어보는 것*/ 
		if(dp[wrong][pos+1][cnt+1+N] >= k) { //왼쪽 자식이 현재의 k 개수를 포함할 수 있다면 우리가 원하는 값은 저 안에서 커버가 되므로 왼쪽 자식의 방향으로 진행하면 된다.
			sb.append('(');
			trackingParen(pos+1, cnt+1, wrong, k);	//해당 dp로 진행했고 그 dp를 루트로 다시 왼쪽 자식 오른쪽 자식을 비교하러 간다.
		}
		
		/**만약 오른쪽 자식으로 가야한다면, 즉 )을 붙여야 하는건가 물어보는 것*/ 
		else { //위에서 왼쪽 자식안 보다 더 큰 개수가 남아있다면 오른쪽의 자식으로 진행하면 된다.
			sb.append(')');
			trackingParen(pos+1, cnt-1, 
					(wrong==1||cnt<=0)? 1 : 0, k - dp[wrong][pos+1][cnt+1+N]); //해당 dp로 진행했고 그 dp를 루트로 다시 왼쪽 자식 오른쪽 자식을 비교하러 간다. 
			// 이 때, 현재의 k는 pos, cnt, wrong라는 현재 정보의 시작위치에서 자신이 몇번째인지 알려주는 정보가 된다. 그렇기에 다음 녀석은 다음 녀석 기준으로 몇번째인지 알려줄 필요가 있다.  
			// 이걸 반절 나누기로 생각하면 더 완벽하게 이해된다. 트리에서 반절을 나누는 이분으로 진행을 하는건 왼쪽자식 기준으로 가면 k가 왼쪽자식에게만 포함되었음을 알려주므로 그 k값 그대로 쭉 왼쪽으로 나갈수있는 것이고, 
			// 오른쪽으로 진행한다면 오른쪽 자식에게만 포함되어야 하는데 이때 k의 번쨰수는 현재 pos,cnt,wrong의 정보를 갖는 dp가 갖고있는 상태로 보존된 상황에서 맨 처음인 값을 기준으로 진행해서 왼쪽자식부터 오른쪽자식으로 번째를 알려준다.
			// 따라서 오른쪽 자식만 포함한 개수(번째)를 전달해야 한다면 k에서 왼쪽 자식의 개수만큼을 제외해야 순수히 오른쪽 자식에 포함될 개수(번쨰)를 가져갈수있다. 말했듯이 k번쨰는 왼쪽 자식의 번째부터 시작해서 오른쪽 자식의 맨 마지막 번째로 진행하기 때문이다.
		}
	}//=============================================
	
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] temp = br.readLine().split(" ");
		N = Integer.parseInt(temp[0]);	//N <= 50
		K = Long.parseLong(temp[1]);	//k <= 2^N - 1
		sb = new StringBuilder();
		dp = new long[2][N+1][N*2+2];	//[wrong_flag][pos][cnt]
		
		for(int i=0; i<=N; i++) {
			Arrays.fill(dp[0][i], -1);
			Arrays.fill(dp[1][i], -1);		
		}
		
		findGalho(0, 0, 0);
	
		/*System.out.println(""+dp[0][0][N]);
		System.out.println(""+dp[0][1][N+1]+" "+dp[1][1][N-1]);
		System.out.println(dp[0][2][N+2]+" "+dp[0][2][N]+" "+dp[1][2][N]+" "+dp[1][2][N-2]);
		*/
		
		//아예 만들수가 없다면 루트 개수 안에도 없다.
		if( K+1 > dp[0][0][N] ) {
			System.out.println(-1); return;
		}
		
		trackingParen(0,0,0,K+1);
	
		System.out.println(sb.toString());
	}//=============================================
	
	/* // open: '('개수, close : ')'개수, val:현재 가지고온 수 번호. 
	static void gg(int open, int close, long val) {
		//System.out.println(open+" "+close+" "+val);
		int n = open + close;
		if(n == N) {
			if(open==close)
				set.add(val);
			return;
		}
		if(open <= N/2)
		gg(open+1, close, val<<1);
		if(open>close) 
			gg(open, close+1, (val<<1)+1);
	}//====================================
	
	static void val2Bit(int n, int k) {
		Deque<Integer> stack = new ArrayDeque();
		int temp = k;
		while(temp!=0) {
			stack.push(temp%2);
			temp /= 2;
		}
		int size = stack.size();
		for(int i=0; i<n-size; i++) {
			sb.append('(');
		}
		while(!stack.isEmpty()) {
			int now = stack.pop();
			if(now==0)
				sb.append('(');
			else
				sb.append(')');
		}
	}//====================================
	*/
}
