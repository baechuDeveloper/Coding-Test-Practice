package Sparse_Table;

public class About__Sparse_Table {

	/** https://m.blog.naver.com/kks227/220793361738
	 * 어느정도 간단하면서 다른 상위 테크닉에 베이스로 쓰이는 테크닉 하나를 다루려고 합니다.
	 * 바로 '희소 테이블'(sparse table)이라는 건데요. 영어단어 sparse는 희소하다는 것을 의미하는데,
	 * 이 단어조차도 어렵다면 쉽게 풀어서 밀도가 적다고 할까요. 공간 안에 상대적으로 굉장히 적은 양의 값만 존재하는 겁니다. 
	 * 
	 * 모든 정점의 나가는 간선이 정확히 1개인 유향 그래프가 있다고 합시다. 어떤 정점에서 시작해서 내가 정확히 k번 간선을 타고 나가겠다고 하면,
	 * k번의 이동 후 도착점이 유일하게 정해지게 되죠. 물론 이 k번의 이동을 일일이 매번 따라갈 수도 있겠지만, k가 굉장히 크면 시간이 오래 걸릴 수도 있습니다.
	 * 
	 * 만약 우리가 어떤 정점의 바로 다음 정점 말고, 여기서 2번 이동했을 때 도달하는 유일한 정점이 어딘지 또 정점마다 다 기억해두고 있다면, 
	 * 우리가 만약 3번 이동하고 싶다고 할 때 이 배열을 사용해서 먼저 두 번의 이동을 한번에 뛰고, 간선을 한 번 타면 3번이 아닌 2번의 값 참조만으로 도착지를 알 수 있고, 
	 * 5번이면 3번, 7번이면 4번... 이렇게 보다 효율적으로 줄어들겠죠.
	 * 이 아이디어를 사용해서 우리가 H번 이동했을 때 도달하는 정점을 배열로 기억하고 있다면, H가 작으면 큰 k에 대해 답을 빨리 내지 못하고,
	 * H가 크면 큰 k에 대해서는 답을 빨리 내지만 H보다 작은 k에 대해서는 O(H)번 따라가야만 합니다. H값의 크기에 따라 일장일단이 존재하죠.
	 * 만약 이런 배열이 두 개면 우리가 유리한 쪽으로 입맛대로 골라서 사용하거나, 둘 다 사용해서 효율적으로 쓸 수 있을 것 같습니다. 
	 * √H번 이동했을 때 도달하는 정점 배열을 추가로 기억하고 있다고 해 보면, 작은 k에 대해 연산 횟수가 O(√H)로 줄어듦을 알 수 있습니다. 
	 * 이걸 좀 깔끔하게 해볼 수 없을까요?

	 * 분할 정복 글에서 A^B를 빨리 하는 방법이 있었습니다. O(B)번이 아니라 O(logB)번의 곱셈만으로 해결이 가능했습니다. 이것도 비슷합니다.
	 * 희소 테이블은 정적 구간 질의를 처리할 수 있는 자료구조입니다. 대부분의 구간 질의를 O(logN)시간에 처리하지만, 특정 연산에 한해서는 O(1)시간도 가능하다는 특징이 있습니다.
	 * 희소 테이블로 구간 질의를 처리하기 위해선, 배열이 '정적'이어야 합니다. 정적이란 말은 지정한 배열의 값의 수정이 된다면 안된다는 의미인데, 
	 * 만약 중간에 배열 값이 변경한다면 희소 테이블은 처음부터 다시 계산되어야 하기 때문입니다. 
	 * 그리고 구간 질의라는 것은 저장된 자료구조(배열이든)에서 임의의 구간이 주어 졌을 때, 그 구간에 대해 어떤 질문에 대해 답을 내놓는 것을 말합니다.
	 * 함수처럼 f(2) = 19 라고 하는 것처럼 2에 해당하는 구간에서 19라는 답을 제시해야하는 것을 말하는 경우도 있습니다. 
	 * 만약 어떤 구간에서 부분적으로 {10, 20, 30, 40}이라는 구간이 있을 때 최소를 구하라고 한다면 10을 주면 됩니다. 이런 것을 구간 질의라고 합니다.
	     
	 * A^B를 빨리 할 때 뭔가 지수를 반으로 나눠서 해결했던 것처럼, 여기서도 2에 기대 볼 수 있습니다.
	 * 1번, 2번, 4번, 8번, 16번, ... 의 이동에 대한 배열을 모조리 만드는 것이죠.
	 * 배열의 개수가 너무 많은 것이 아닌가? 생각할 수도 있으나, 만약 주어지는 k 값의 최댓값이 M이라 하면 배열의 개수는 O(logM)개만 필요한 것을 충분히 알 수 있습니다.
	 * 정점 개수가 N개일 때 각 배열은 N개의 값을 필요로 하므로 총 O(NlogM)의 공간복잡도가 요구되는데, 대부분의 문제에서는 이 정도는 넉넉합니다.
	  
	 * 그럼 이 배열을 가지고 어떻게 할까요? 이동 횟수 k를 2진수로 나타내었을 때 켜져 있는 비트에 해당하는 배열들만을 사용해 건너뛰면 됩니다.
	 * 예를 들어 k = 13이라면 이진수로 나타내었을 때 "1101(2)"이므로, 켜져 있는 비트에 해당하는 1칸, 4칸, 8칸 이렇게 총 3번 뛰면 됩니다. 
	 * 뛰는 순서에는 상관이 없다는 점에 주목하세요. 이 때문에 이를 구현하는 방법은 상당히 다양합니다. 
	 * 또, 충분한 배열이 준비되어 있다는 가정하에 답을 구하는 데 드는 시간은 O(logk)임도 알 수 있죠. k의 최댓값이 M이면 O(logM)을 보장할 수 있습니다




	
	 * 아이디어
	 * 모든 음이 아닌 정수는 2의 거듭제곱 항의 합으로 유일하게 나타낼 수 있습니다. 
	 * 51 = (110011)2 이진수 로서 32+16+2+1로 나타낸 것처럼 음이 아닌 정수는 이렇게 표현이 가능하죠. 여기서 항의 개수는 log2(x)개(로그 밑2의 x)가 됩니다
	 * 이 점을 이용합니다. 
	 * 
	 * 어떤 구간은 길이가 2의 거듭제곱인 구간의 합구간으로 유일하게 나타낼 수 있습니다. 
	 * 예를 들어 구간 [3<= x <53] (이하, [3, 53])은 길이가 51인 구간이며, 길이가 각각 32, 16, 2, 1인 구간의 합 구간으로,
	 * 
	 * [3, 53] = [3, 34] || [35, 50] || [51,52] || [52,53] 
	 * 으로 나타낼 수 있습니다. 2의 거듭제곱의 범위인 구간 값을 미리 계산(전처리)해놓는다면, 질의 하나를 처리하는데 log2(length of interval)번의 연산만이
	 * 필요하게 될 것입니다. 질의로 어떤 구간이 주어지더라도 2의 거듭제곱인 범위의 구간으로 나눌 수 있으니 미리계산된 logN개의 구간 값을 가져와 합쳐주기만 하면 됩니다.
	 * 
	 *  
	 *  아무튼 아무튼 
	 *  1번, 2번, 4번, 8번, 16번, ... 의 이동에 대한 배열을 모조리 만드는 것이죠.
	 *  배열의 개수가 너무 많은 것이 아닌가? 생각할 수도 있으나, 만약 주어지는 k 값의 최댓값이 M이라 하면 배열의 개수는 O(logM)개만 필요한 것을 충분히 알 수 있습니다. 정점 개수가 N개일 때 각 배열은 N개의 값을 필요로 하므로 총 O(NlogM)의 공간복잡도가 요구되는데, 대부분의 문제에서는 이 정도는 넉넉합니다.
	 *  그럼 이 배열을 가지고 어떻게 할까요? 이동 횟수 k를 2진수로 나타내었을 때 켜져 있는 비트에 해당하는 배열들만을 사용해 건너뛰면 됩니다.
	 *  예를 들어 k = 13이라면 이진수로 나타내었을 때 "1101(2)"이므로, 켜져 있는 비트에 해당하는 1칸, 4칸, 8칸 이렇게 총 3번 뛰면 됩니다. 뛰는 순서에는 상관이 없다는 점에 주목하세요. 이 때문에 이를 구현하는 방법은 상당히 다양합니다. 또, 충분한 배열이 준비되어 있다는 가정하에 답을 구하는 데 드는 시간은 O(logk)임도 알 수 있죠. k의 최댓값이 M이면 O(logM)을 보장할 수 있습니다.
	 *  
	 * **/
	
	
}
