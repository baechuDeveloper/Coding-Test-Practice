package Sparse_Table;
import java.util.*;
import java.io.*;

/**
 * 우선 중요한 점은 어느점에서 다른점으로 가는 방법이 항상 유일하다 라는 점. 
 * 그리고 주어질 굴의 개수도 n-1라는 점으로 이 그래프는 '트리구조' 이다.

 * 여기서 결과적으로 1이라는 곳으로 향할려고 한다면, 1을 트리의 루트로 두면 될 것이다. 
 
 * cave_dist도 지수 거리만큼 이동했을 때 그 거리량을 알려주는데, 아무리 최대 지수라도 결국 트리의 루트까지 도달했을 때 값을 가지고 있고 어느정도 높은 지수는 계속 이 값을 유지할 것이다. 
 * 지수가 점점 낮아져서 루트의 도달한 거리양보다 작아지면 그 때는 루트보다 아래인 노드가 해당 지수에 이동만큼한 노드로서 있음을 알려준다. 
 
 * 이러한 점을 이용해서 현재 에너지가 28이라면 최대지수의 거리양이 20이라 할 때, 해당 개미는 루트까지 충분히 도달할 수 있음을 알 수 있다.
 * 반대로 현재 에너지가 14라고 할 때, 최대지수의 거리양은 20라서 루트에는 도달하지 못한다. 그렇다면 그 지수를 줄여서 거리양이 14보다 작거나 같은 값을 찾는다.
 * 어느정도 내려가보니 해당 지수의 거리양이 8인 것을 찾았다. 그렇다면 '현재 개미의 위치'에서 해당 지수의 거리 8만큼 이동을 해서 '해당 지수의 위치k'에 도달하고,
 * 남은 거리인 6만큼을 '해당 지수의 위치k'가 '현재의 위치k'로 두었을 때로 하여 새로히 다음에 갈만한 지수h만큼을 계산한다. 이때 해당 지수h는 이미 k만큼의 지수를 지나왔으니 
 * 적어도 k보다 클 수 가 없다. 최대지수가 18일때 k가 14라면 h는 14보다는 절대로 클 수가 없고 그 아래부터 찾아가 남은 거리 8에 해당하는 지수 거리량을 찾으면 될 것이다.
 
 * 한가지 또 k에 대한 예시를 직접 주겠다. 에너지 말고 단순히 해당 위치에 도달한다는 점만 고려했음을 알아달라. 지수를 풀어낸 값이 256(k=8)이라할 때 정답으로 도달한 위치가 255에 해당하는 거리라고 미리 알고있다하자.
 * 그러면 255에 도달할려면 어떻게 되는지 작동대로 진행보겠다. 우선 128(k=7)에 해당하는 점에 갈수있다. 이제 남은 건 127이된다. 이는 또한 128로도 도달이 안되니 64(k=6)로 진행을 한다.
 * 이제 63이 남고 이렇게 계속하여 31...15...7...3...1 이렇게 진행하여 도달 할 수 있다. 
 * 이 방법대로 해보면 다음 살펴볼 지수값은 항상 도달했을때 지수보다 낮은 값부터 시작하게 된다. 이미 그보다 윗단계k=8에서 안되므로 바로 아랫단계k=7을 이미 한번 해서 또 다시 k=7을 할 수 있었다면 
 * k=8도 되었을 테니 말이다. "여기서 말하고자 하는건 지수는 점차 내려가는 구조로 해서 원하는 위치에 충분히 도달 할 수 있다는 점"이다.    
 
 * 위는 에너지가 없을 때를 기준으로 한것인데 우리가 풀고자 한건 에너지 기준으로 도달 할 수있는 굴의 위치가 어느정도 인지 알아보는 것이다. 
 * 이도 마찬가지로 에너지를 소비해가며 위치를 이동하고 또 새로운 위치에서 지수를 주는 방식이 위와 동일할 것이다. 높은 지수부터 시작해서 어느 지수k에서 가능하면 그 지수에 해당하는 
 * 점으로 도달하고 다시 그 점에서 지수k보다 낮은 상태에서 찾아보면 되는 것이다. 위와 똑같은 이유로 지수가 점차 내려가는 구조로 해서 남은 에너지로 도달할 수 있는 점에 가면 된다.
 
 * 이 최대 지수에서 시작해서 줄여서 해당되는 값이 되면 이동하고 나머지는 분명 지금의 지수보다 낮은 지수의 개수를 가지므로
 * 바로 이어서 해당 지수의 아래부터 진행을 하는 이 기법이 희소배열을 최대로 유용하게 사용할 수 있는 방법인것 같다.
 **/

// 14942번 - 개미
public class p2__Ant {

	static int n;				//방의 개수	1 <= n <= 100_000
	static int[] energy;			//각 방에 존재하는 개미가 보유하고 있는 에너지 값	(1번 개미부터 n번 개미까지) 
	static ArrayList<ArrayList<Edge>> childNode;	//동굴에 붙어있는 간선을 알려줌.
	static int[][] parent;		// [ 지수 ][ 시작하는 점 ] = 시작하는 점에서 몇번의 이동을 했을 때 도착할 동굴
	static int[][] cave_dist;	// [ 지수 ][ 시작하는 점 ] = 시작하는 점에서 몇번의 이동을 했을 때 도착한 거리
	static int MAX_DIGIT = 18;	// 2^17 = 1024 * 128 = 약 1000 * 128 = 약128_000 이다. n의 최대 100_000이니 커버가 된다.
	//=======================================================
	//간선에 대해 다음 점과 거리를 알려주게 하는 자료구조
	static class Edge{
		int next, cost;
		Edge(int b, int c){
			 next=b; cost=c;
		}
	}//=======================================================
	//Tree구조로 각 노드의 부모가 누군지 알아내어 parent배열을 완성한다.
	static void makeTree(int root) {
		ArrayList<Edge> childlist = childNode.get(root);
		for(Edge edge : childlist) {
			int child = edge.next;
			if(parent[0][child]==0) {	//처음 방문으로 더 윗 층의 노드가 될거임
				parent[0][child] = root;	//너의 직속 부모는 나다.
				cave_dist[0][child] = edge.cost;		
				makeTree(child);
			}
		}
	}//=======================================================
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();

		//동굴의 수 입력
		n = Integer.parseInt(br.readLine());

		//각 개미가 가진 에너지 입력
		energy = new int[n+1];
		for(int i=1; i<=n; i++) 
			energy[i] = Integer.parseInt(br.readLine());

		//각 동굴의 간선을 입력
		childNode = new ArrayList<>();
		for(int i=0; i<=n; i++)
			childNode.add(new ArrayList<>());
		for(int i=0; i<n-1; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int c = Integer.parseInt(st.nextToken());
			childNode.get(a).add(new Edge(b, c));
			childNode.get(b).add(new Edge(a, c));
		}

		//부모에 대해 구해본다. 
		parent = new int[MAX_DIGIT][n+1];
		cave_dist = new int[MAX_DIGIT][n+1];
		parent[0][1] = -1;	//Tree작업이 끝나면 parent가 -1인 노드가 1번 동굴이며 이게 루트이다.
		makeTree(1);		//루트를 1로한 트리에서의 부모를 알려줌. 이는 조건에서 트리라고 주었기에 만들기만 하면 됨.

		//전체 희소배열을 등록한다. 
		for(int j=1; j<MAX_DIGIT; j++) {
			for(int i=1; i<=n; i++) {
				if( parent[j-1][i] != -1 ) { //배열에 들어갈게 -1이면 안되는 것도 있고, 이미 중간에서 -1 넘어가는 경우라는 의미인데 그렇다면 더 진행 안해도 된다. 
					parent[j][i] = parent[ j-1 ][ parent[j-1][i] ];	//i에서 j-1번 이동한 점. 그 점에서 다시 j-1번의 이동을 하면. 2의j-1을 가고 2의j-1을 가서 2의j승이 되는것이다.
					cave_dist[j][i] = cave_dist[j-1][i] + cave_dist[j-1][ parent[j-1][i] ];
					//2^(j-1)이 원래 내 자리에서 온 거리와 이동된 점에서 j-1을 간 거리를 뜻하게 된다. j-1은 딱 이전에 서로 구해두었다. 
					//원래 i에서 시작해서온 j-1번의 거리와 j-1로 도착한 그 점에서 다시 j-1번을 한게 새롭게 도착할 곳의 거리의 합이다.
				}
				//parent의 값들은 모두 동굴의 번호의 범위안에서 계속 이루어지게 된다. 그중 예외가 바로 -1이다. 그리고 0은 범위안에 절대 들어갈 수 없다. 아무리 뻉뻉이해도 0을 가리키는 노드는 아무도 없어서다.
				//-1을 부모로 처음 둔것은 바로 1번동굴이다. 차례대로 진행되는 순서에서 맨먼저 1번동굴의 부모가 -1이며 앞으로도 계속 몇번의 지수가 되든 일정한 값을 유지시키게 한다.
				//그리고 루트에 가장 가까운 노드들(편의상A)이 그 다음으로 1번을 가리키고 부모가 -1이 되게 된다. 그러면 이 가까운 노드들A도 그 다음의 몇번의 지수든 일정한 값을 유지하게된다.
				//이렇게 점차에 루트에서 그 다음으로 먼 노드들(편의상B)은 진행하다가 가리키게 될것이 A노드들 중 하나가 될것인데, 
				//A를 가리켰다면  결과적으로 1번노드가 더 진행한 지수만큼에 도달하거나과 A번 노드가 더 진행해서 이제 계속 -1을 가리키는 것으로 도달하게 되어 이 B들도 -1에 도달하고 그 이후로는 일정한 값을 유지하도록 하면된다.
				//이를 점차 밑의 노드들에게도 퍼져나가면서 '루트를 넘어서는 지수만큼의 거리까지 왔다면 차례대로 진행을 해와서 루트에 해당하는 거리만큼을 알려주고'
				//앞으로도 그 값은 계속 지속되어 일정하게 가져간다. 
				//또한 앞으로도 -1임을 계속 정해준다.
				else {	
					//차례대로 진행되는 순서에 따라 -1은 결국 '이전 상태가 루트에 해당하는 위치'임을 알려주는 형태가 된다. 물론 지수에 해당하는 위치에 따르면 아득히 위로 올라갈거 같은데 이 else덕분에 넘어간 상태에서도 -1과 거리를 유지했고, 
					//위의 if조건으로 루트에 도달하는 거리만큼을 계산하고 -1에 지수를 넘는 수치가 아닌 정확하게 도달했을 때가 반드시 존재하기에 가능한 구조가 된다. 그리고 정확히 도달하고 나서부터 해당 개미는 else덕분에 큰 지수가 되어도 유지가 된다.
					//이말은 사실 더 먼 k만큼 띄어갔을지라도 해당 노드에서는 그만큼의 k도 모두 일처리를 끝냈고, 그 끝낸 일처리도 이전의 루트에 도달한거라면 루트에 도달한 양만큼을 유지해주기때문이다.  
					parent[j][i] = -1;
					cave_dist[j][i] = cave_dist[j-1][i];
				}
			}
		}
		
		//1번동굴은 항상 1번동굴이니 
		sb.append(1+"\n");
		//각 개미들이 도달할 수 있는 동굴의 위치를 찾는다.
		for(int ant=2; ant<=n; ant++) {
			//System.out.println("현재 개미 : "+ant);
			int now = ant; //현재 개미가 위치한 굴번호
			int now_energy = energy[now];	//현재 남아있는 개미의 에너지
			
			for(int k=MAX_DIGIT-1; k>=0; k--) {
				int need_energy = cave_dist[k][now]; //현재 지수에 도달하기위해 필요한 에너지
				//System.out.print("위치 : "+now+" 남은 : "+now_energy+" 필요 : "+need_energy);
				//현재 지수만큼을 현재 남아있는 에너지로 움직일 수 있을 때 들어온다.
				if(need_energy <= now_energy) {
					now_energy -= need_energy;	//해당 지수에 도달할만큼의 에너지를 소비한다. 
					now = parent[k][now];	//해당 지수만큼 이동해서 위치한 굴에 도달해서 갱신
				}
				if(now_energy<=0  || now==-1) {	//이미 에너지를 다 썻거나, 루트에 해당하는 장소로 도착했다면 더이상 진행 할 필요가 없다.
					if(now==-1) now=1;
					break;	
				}
			}
			//now에 최종으로 남아있는것은 결국 현재 있는 에너지로 이동할 수 있는 최종 굴의 위치가 된다. 
			sb.append(now+"\n");
		}
		bw.write(sb.toString());
		bw.flush();

	}//=======================================================

}
