package Sparse_Table;
import java.util.*;
import java.io.*;

/**=============================================================
 
 * '우선 가장 선행되야하는 조건'이  f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn : {1, 2, ..., m}→{1, 2, ..., m}을 이렇게 정의한 것.
 * 이 규칙이 있어야 합성함수에서 작업이 가능하다. 그렇지 않다면 희소테이블은 가능하지 못할 것이다.
 
 * f1(x) = f(x)
 * f2(x) = f(f(x))
 * f4(x) = f(f3(x)) = f(f(f(f(x))))
 * fn+1(x) = f(fn(x))
 * 
 * n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오
 * -----------------------------------------------------

     희소 테이블 
 * 합성함수를 해결하기 위해 n번 반복하는 것이 아닌 미리 테이블을 만들어 특정원소에서 1번 갔을 때, 2번 갔을 때, 4번, 8번, 16번와 같이 
 * 이진수의 자리수 만큼 이동했을 때의 도착지들을 2차원 배열로 모두 만들어 놓는 것입니다.
 * 
 * 예를 들어 f(1,2,3,4) -> (2,1,4,3) 라는 함수가 있을 때
 * f(f(f(f(f(f(1))))))와 같이 '6'번 합성된 합성함수를 구하기 위해 우선 '6'을 '이진수'로 바꿉니다. 6 = (110)2
 * 이제 위의 이진수에서 자리수가 1인 것의 의미는 해당 수 만큼 숫자를 바꾸어 주면 되는 것입니다.
 * 1을 4(100)번 옮기고 나온수를 2(10)번 옮기면 원하는 정답을 구할 수 있는 것이지요.
 * 1을 4번 옮기는 동작은 미리 만들어진 희소테이블에 의해 알 수 있습니다. 
 * 따라서 총 6번 걸리는 동작을 희소테이블 이용함에 따라 2번으로 줄일 수 있는 것이지요.

 * f(1), f(2), f(3), ... , f(n)으로 f(x)함수에 매개변수 x에 따른 함수 값이 들어있다.
 * f2(x)를 구하려면 f(f(x))이면 가능하고
 * f4(x)를 구하려면 f2(f2(x))이면 가능하고
 * f8(x)를 구하려면 f4(f4(x))이면 가능합니다. 
 * f_n(x) x에서 n번 이동 후 어디에 있느냐 입니다.
 * 
 * 이러한 점을 이용해서 이진수를 덛붙혀서 작업해 봅시다.
 ================================================================*/

/*
 * 여담으로 합성함수가 아닌 만약 단순히 n^k처럼 n의 k승 문제는 이진수로 해당 값을 조금씩 지수에 맞게 줄여가며 푸는것이고, 지금 문제는 지수문제가 아닌 합성함수로서의 문제이다. 
 * 지금 합성 문제는 조건까지 합하면... 모든 정점의 나가는 간선이 정확히 1개인 유향 그래프가 있고, 어떤 정점에서 시작해서 내가 정확히 k번 간선을 타고 나가겠다. 
 * 그래서 k번의 이동으로 나오는 결과값을 알려주는 것과 같다.
 * 이 예시는 트리와 같은 경우도 1개의 유향그래프라서 가능할 것이다. 
 * */

// 17435번 - 합성함수와 쿼리
public class p1__Sparse_Table {
	
	static int[][] next; 		// next[j][i] = 어느 값 i에서 2^j번 이동한 후의 정점 
	// [ 지수 ][ 함수로 나온 결과 값이자 시작 값(이 함수로 나온 결과값이 f2, f4 처럼 이런 2의 지수의 결과이기에 DP적으로 아래서 반드시 쌓아 올려지게된다.) ]
	// 위의 말은 사실상 우선되는 조건  fn : {1, 2, ..., m}→{1, 2, ..., m} 이 있기에 가능한 방식이다. 
	// 저기 범위안에 값중 하나로 진행되어 연속적으로 합성하는 함수로 값이 진행되기에 가능하다. 
	
	
	static int MAX = 200_001;
	static int MAX_DIGIT = 19;	// 2^k >= MAX인 최소의 k 	200_000은 2^19보다 항상 작다 .
	//=======================================================
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringBuilder sb = new StringBuilder();
		int m = Integer.parseInt(br.readLine());	// 1부터 M까지의 배개변수에 따른 f(x)함수의 값을 나타내줄것이다.	1<= M <=200,000
		next = new int[MAX_DIGIT][MAX];
		// f(1)부터 f(m)까지 값을 넣어줌 
		StringTokenizer st = new StringTokenizer(br.readLine());
		for(int i=1; i<=m; i++) 
			next[0][i] = Integer.parseInt(st.nextToken());	//2^0에 해당하는 각 값을 넣어준다. 	
		
		/**--------------------------------------------------------------
		 작은 j부터 배열을 채워가면서 전체 배열을 채울 수 있다.

		 우리가 접근할 점화식은 f2(x) = f1(f1(x)), f4(x) = f2(f2(x)), f8(x) = f4(f4(x)) 이렇게 구해가는것이다. 
		
		 이걸 이제 지수만 써서 보이면 
		 f2(i) = f(2^1)(i)  = f(2^0)( f(2^0)(i) )
			   = next[1][i] = next[0][ next[0][i] ]
		
		 f4(i) = f(2^2)(i)  = f(2^1)( f(2^1)(i) )
			   = next[2][i] = next[1][ next[1][i] )
		
		 f8(i) = f(2^3)(i)  = f(2^2)( f(2^2)(i) )
			   = next[3][i] = next[2][ next[2][i] ]
		
		 *z는 2의 어떠한 지수 값중 하나
		 fz(i) = f(2^(j+1))(i)  = f(2^j)( f(2^j)(i) )
		 	   = next[j+1][i]   = next[j][ next[j][i] ]		
		
	 	참고로 이건 아니다. f(j+1)(i) = fj(f1(i))	물론 그냥이면 맞지만 내가 j로 두는건 '지수'다 그러니 이 식 자체가 아니다. 
	
		그러니 이러한 점화식을 만들어줄 수 있다. 
		next[j+1][i] = next[ j ][ next[j][i] ]
		
		MAX_DIGIT만큼 채워주면 알고자하는 n의 값을 이진수로 두어 각 해당하는 지수값을 하나씩 통과해 가며 결과값에 도달해 간다.  
		--------------------------------------------------------------**/
		for(int j=1; j<MAX_DIGIT; j++) {
			for(int i=1; i<=m; i++) {	
				next[j][i] = next[ j-1 ][ next[j-1][i] ];
			}
		}
		
		/**--------------------------------------------------------------
		 * 예를 들어 13이면	 13 = 8+4+1 = 2^3 + 2^2 + 2^0
		 * f13(2)을 구하라고 한다면 f13(2) = f8(f4(f1(2))) = f2^3( f2^2( f(2^0(2)) ) ) 	//물론 여기가 f4(f1(f8(2))) 이라도 똑같다.
		 --------------------------------------------------------------**/
		int Q = Integer.parseInt(br.readLine());	//쿼리의 수,	1<= Q <= 200,000
		for(int q=0; q<Q; q++) {
			st = new StringTokenizer(br.readLine());
			int n = Integer.parseInt(st.nextToken());
			int x = Integer.parseInt(st.nextToken());
			//fn(x)를 구해라!
			for(int j=0; j<MAX_DIGIT; j++) {
				if( (n&(1<<j)) > 0) {
					x = next[j][x];	//우선 해당 j에서 2의 지수값이 나왔으니  fj(x)를 구해서 안쪽 매개변수로 바꾸어 더 진행을 한다. fj(x)에 해당하는 값은 이미 구해두었고 
				}
			}
			//x에는 마지막에 도착한 지점을 알려준다. 
			sb.append(x+"\n");
		}
		bw.write(sb.toString());
		bw.flush();
	}//=======================================================
	
}
